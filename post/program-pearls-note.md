<!---
title:: 编程珠玑读书笔记
date:: 2016-02-28 21:08
categories:: 算法
tags:: algorithm 
-->

前两天很快把《编程珠玑》看了一遍，没有仔细去思考一些问题，决定先写个读书笔记来回顾一下这本书中的精华。
<h4>CH1 开篇</h4>
关于磁盘文件的排序问题，运行时间和运行内存都有限制。最初的两种方案，一种是非in-place的归并排序，一种是in-place的快速排序。

在经过对问题的理解和思考都，提出位图的解决方案，这个解决方案需要使用1.25MB的空间开销，比要求的1MB多。关于位图bitmap的代码在以前Pintos中有源码，功能比较强大，可以直接修改用于这个问题。

这个问题的完美解决在于对问题的明确，使用了正确的数据结构，导致最终的解决很简洁，达到时间和空间上的双赢。

摘抄：对小问题的仔细分析有时可以得到明显的实际益处。减少程序的空间需求也会减少其运行时间。
<h4>CH2 啊哈！算法</h4>
这一章有3个问题：A.给定一个最多包含40亿个随机排列的32位整数的顺序文件，找出一个不在文件中的32位整数；B.将一个n元一维向量向左旋转i个位置；C.给出一个英文字典，找出其中的所有变位词集合。

问题A，在没有足够内存的情况下，书中并没有给出明确的解法，只是给出了二分搜索的思路，在习题解答中给出了答案。我自己想出来的解法是：二分搜索+顺序扫描统计大于小于中位数的个数，可以确定下一次扫描的范围，如果序列中没有中位数，直接返回中位数，运行时间为O(nlogn)。习题解答中给出的答案是通过最高位0/1探测，可以是总的运行时间为O(n)。二分搜索是一个很常用的算法，在很多情况下可以得到应用，这个需要经验的积累。

问题B，我理解和接受的后两种方法：一种就是将问题规模变小然后递归解决；另一种用3个基本的reverse操作完美解决整个问题。两种方法的代码实现都不是很难。

问题C，主要涉及到对字符串排序，以字符串的排序结果作为唯一标示，在2.8节中给出了一个完整的实现，很好理解。
<h4>CH3 数据决定程序结构</h4>
3.1节中介绍了一个通过使用数组这种最简单数据结构使程序变得简洁多了的例子，这个例子在现在看来很显而易见。

3.2节介绍的格式信编程的核心思想：将数据从控制中分离。这种思想和现在Web开发中MVC框架中数据和逻辑分离的思想是一致的。

3.3节中举了一些例子来说明3.1和3.2节中的观点。对于我来说，我觉得有时在程序中添加一些数组类似结构存储数据，将数据和逻辑分离是一个很好的想法。

3.4节主张数据要结构化，3.5节提出了几种结构化数据的工具，对于我来说，key-value pair和database是了解该怎么用的。

将大程序缩减为小程序，数据结构设计还有许多其他正面影响，包括节省时间和空间，提高可移植性和可维护性。

几条原则：1.使用数组重新编写重复代码；2.封装复杂结构；3.尽可能使用高级工具；4.从数据得出程序的结构。
<h4>CH4 编写正确的程序</h4>
这章主要是通过二分搜索排好序的数组来说明程序正确性的验证，使用了循环不变式这种技术来证明迭代控制结构的正确性。循环不变式在CLRS中很详细的说明，在证明一些不是很复杂的迭代控制结构的确很方便，对于一些复杂点的，自己有时感到很无力。

这个章节的内容对我以后写代码时的注释有一些启示。程序的注释是和程序正确性相关的说明才是有效的，否则就可能是画蛇添足。
<h4>CH5 编程小事</h4>
这章的内容涉及代码测试，调试这些内容，自己没有特别多的感想，这里不赘述。对于调试，永远不要忘记，无论系统的行为咋看起来多么神秘莫测，其背后总有合乎逻辑的解释。

<h4>CH6 程序性能分析</h4>
为了加速程序，我们可以从以下几个方面入手：1.问题定义；2.系统结构；3.算法和数据结构；4.代码调优；5.系统软件；6.硬件。

对于我来说，可能3,5,6可能是更加熟悉的，体会比较深一些。对于1，这个需要重视，CH1中的例子就说明对问题的明确可能得到更优的解法。
<h4>CH7 粗略估算</h4>
“72法则”：如果以年利率r%投资一笔钱y年，金融版本的“72法则”指出，如果r*y=72，那么你的投资差不多会翻倍。

John Roebling设计大桥给我们的启示：使用很大的安全系数来补偿自己的知识局限。在我们设计代码系统时也应该这样，不应该不懂装懂。

Little定律和排队论相关，虽然自己排队论相当于没学，但这个定律还是可以理解的：队列中物体的平均数量为进入速率与平均停留时间的乘积。
<h4>CH8 算法设计技术</h4>
这章针对一维的模式识别的问题，给我们展示了：算法上的灵机一动可以使程序更加简单，这种灵机一动往往是转换一个角度来看问题，对问题进行了重新定义，也许对于没有足够嗅觉的我很难想到；复杂深奥的算法有时也可以极大提高程序的性能，这些算法往往使用一些成熟的数据结构或者算法思想，虽然可能让代码变得更加复杂，但是也可以提高性能。

问题的输入是具有n个浮点数的向量x，输出是输入向量的任何连续子向量中的最大和。

O(n**3)解法：对这个问题最直观能够得到的解法是：对于每个整数对，程序都计算x[i...j]的和，并检验是否为最大。这段代码简单，直观，易于理解，但是有太多冗余计算，因此时间复杂度度很高。

O(n**2)解法：消除O(n**3)解法中的冗余计算，我们就可以得到两种O(n**2)解法。其中第一种比较直观，第二种做了一点点问题的转换，预先计算了cumarr向量，在cumarr向量中第i个元素为x[0...i]中各个数的累加和。

O(nlgn)解法：这是一个分治的算法，将原问题分解成为两个相同的问题，对于这个问题，分治的代码有点复杂，稍微有点难以理解，但是能够取到很好的效果，值得。

O(n)解法：这种解法借鉴了分治算法中的思路，但是更像一个动态规划中的状态转换的思路：假设我们已经获得x[0...i-1]中的maxsofar和maxendinghere两个值，那么对于x[0...i]，最大总和要么在qiani-1个元素的maxsofar中，严么在结束位置为i的maxendinghere中。根据这个思路我们就能获得一个递推关系，顺序扫描向量的过程中，保持maxsofar和maxendinghere就行。

对于上面的问题，我们还可以增加一点难度，不仅获得最大的连续子向量的和，还需要获得起始结束下标。除了分治算法采用递归实现可能有一些复杂，其他算法只要在更新最大和时记录起始结束下标就可以。

只有经过广泛的研究和实践，你才能熟练地运用算法设计技术，大多数程序员仅仅是从有关算法的课程或教科书中获得这些知识。
<h4>CH9 代码调优</h4>
代码调优的终极目的就是减少CPU时间，减少分页或者增加高速缓存命中率，或者减少程序需要的空间。

只有在确信没有更好的解决方案时才考虑进行代码调优。

Don Knuth观察发现，不成熟的优化是大量编程灾害的根源，它会危及程序的正确性、功能性以及可维护性。当可能的危害影响较大时，请考虑适当将效率放一放。

Van Wyk的图形程序告诉我们，多数的时间都消耗在少量的热点代码上，代码调优就是要分析找到这些热点代码，对这些热点代码进行优化，对于其他区域，我们遵循有名的格言“没有坏就不要修”。

代码调优有些是计算机体系结构层面的，比如循环展开有助于增加指令的并行性，减少分支；有些是语言层面的，比如整数取模的优化是因为C语言中的取模运算开销很大导致，宏、内联函数替换短小简单函数也是语言层面的，设置哨兵可以减少循环中判断的次数；汇编代码或者机器代码级别的优化代码在一些特别核心的底层代码中也存在，因为这些底层代码会一直不停被调用，属于热点代码。
<h4>CH10 节省空间</h4>
虽然目前计算机的存储容量的问题很容易通过扩容来解决，很多算法可能就是通过牺牲空间获得时间上的优化，但是节省空间的同时会使程序变小加载更快，也更容易填入告诉缓存中，需要操作的数据变少也意味着操作时间的变少。所以，节省空间的技术还是很有必要的。

Fred Brooks通过尝试找到一个匹配整个税表的数学函数来避免使用表来存储。现在由于存储容量的足够，有一些为了时间上更快的代码往往会预先存储表来获得，正好和Brooks反过来。

稀疏矩阵的技术在代码中很常见，Graph的表示很多使用这种技术。

Python中的生成器是典型贯彻“不存储，重新计算”这种理念获得更少的空间使用，但这样时间上就会更大的开销。

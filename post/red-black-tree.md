<!---
title:: 红黑树
date:: 2016-02-29 21:08
categories:: 编程语言, 算法
tags:: algorithm, data structure, tree
-->
过年之前一直在刷leetcode，刷得烦躁了就会看看以前看的一些书，复习一下，导致年前都没怎么写技术博客，马上就要准备实习的面试笔试，觉得有必要好好总结一下学习过的一些东西。

首先声明一下，博文首先是写给自己看的，类似一个技术笔记，我只有在写博文时才会认真起来，平常在纸上做笔记太随意，感觉效果不好。由于是类似笔记，文章可能布道属性很低，如果能对别人有一些借鉴，我会很高兴。
<h4>红黑树的定义与性质</h4>
一颗RB Tree是满足下面红黑性质的BST：
<ol>
	<li>每个结点或红或黑</li>
	<li>根结点为黑</li>
	<li>所有叶结点(NIL)为黑</li>
	<li>如果结点为红，那么它的两个子结点都为黑(也就是说不可能有两个连在一起的红结点)</li>
	<li>对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同的黑色结点</li>
</ol>
从某个结点x出发(不包含该结点)到达一个叶结点的任意一条简单路径上的黑色结点个数称为该结点的黑高(black-height)，简称bh(x).

树中每个结点包含5个属性：color、key、left、right和p，如果一个节点没有子结点或者父结点，则该结点相应指针属性的值为NIL。

一个有n个内部结点的RB Tree的高度至多为2lg(n+1)。

CLRS上给出了一种证明，下面给出通过2-3-4树的证明：
<pre>2-3-4树是B树中最简单的形式，满足以下性质：
1.每个结点(叶子结点或者内部结点)要么是2-node，3-node或者4-node
2.所有的叶子结点有相同的深度
3.结点中数据是有序的

RB Tree根据正则m树的定义为一颗正则2树，也就是二叉树。
注：若根数的每个内点都有不超过m个子女，则它为m元树。
若该树的每个内点都恰好有m个子女，则称为正则m元树。
把m=2的正则2元树称为二叉树。
根据定理：带有i个内部结点的正则m元树含有m*i+1个结点，有(m-1)*i+1个叶子结点，
可以知道有n个内部结点的RB Tree有n+1个叶子

把RB Tree中的红色结点merge到黑色节点的双亲中就成为一颗2-3-4树
RB Tree高度为h1,2-3-4树高度为h2，则显然h1&lt;=2h2

因为2-3-4树中节点至少有2个孩子，至多有4个孩子，所有叶子结点具有相同的深度，则：
高度为h的2-3-4树至少有2**h个树叶，至多有4**h个树叶。

一颗有n+1个叶子结点的RB Tree转换成的2-3-4树也有n+1个叶子结点，于是n+1&gt;=2**h2
h1&lt;=2h2&lt;=2lg(n+1)</pre>
其实RB Tree和2-3-4是等价的数据结构，2-3-4树描述起来很容易理解，但是实现起来比较复杂，红黑树理解起来可能有点晦涩，红黑树的实现较为简洁，所以RB Tree在代码中使用得更多。
<h4>ROTATE</h4>
很多Balanced BST的INSERT和DELETE操作为了保持平衡，需要进行修正，这些修正步骤都会使用树的旋转操作，实现起来也很简单，修改指针，注意一下边缘情况就OK，画图写代码就OK。
<h4>INSERT操作</h4>
RB Tree的插入和BST的插入前面的操作基本一样，除了新插入的结点需要着成RED，然后进行RB Tree的修正操作。

INSERT的修正操作有3中情况(以z.p==z.p.p.left为例，right为对称情况)：
<ol>
	<li>z的叔结点y是RED</li>
	<li>z的叔结点y是BLACK，z是右孩子</li>
	<li>z的叔结点y是BLACK，z是左孩子</li>
</ol>
情况1的处理为重新着色，z=z.p.p上升两层；情况2简单进行左旋操作即可；情况3进行重着色加上右旋即可。

情况1处理完后可能变为1,2,3中任意一种；情况2一定变为3，情况3处理完后while循环肯定结束。

注意代码最后一定要将root结点着成黑色！

INSERT的代码的编写比较简单，基本也是看图写代码+注意边缘情况。

INSERT代码的证明采用循环不变式进行证明，不是很容易看得很明白。
<h4>DELETE操作</h4>
RB-DELETE操作复杂一些，主要是如果删除的结点的颜色为BLACK，如果移到删除结点处的结点的颜色也为BLACK，那么这个结点具有双重黑属性，需要进行修复，RB-DELETE-FIXUP的目标就是将额外的黑色沿树上移，最极限的情况就是多余的BLACK属性上移到了根结点，导致整个树的黑高减少了1.

RB-DELETE和BST的DELETE操作类似，分为3中情况：z结点的左孩子为T.nil；z结点的右孩子为T.nil；z结点的左右孩子都不是T.nil。对于第三种情况，稍微复杂一点需要寻找z的后继结点y，然后用结点y替换z的位置，y的右孩子替换y的位置。在整个过程中需要记录被删除结点的颜色，对于前两种情况，记录z结点的颜色就OK，对于第三种情况，记录z的后继结点y的颜色，因为y替换了z的位置，真实被删除的结点其实是y。

DELETE操作的修正情况有4种(以x=x.p.left为例，right对称)：
<ol>
	<li>x的兄弟结点w是红色</li>
	<li>x的兄弟结点w为黑色，w的两个孩子也都是黑色</li>
	<li>x的兄弟结点w为黑色，w的右孩子为黑色，左孩子为红色</li>
	<li>x的兄弟结点w为黑色，w的右孩子为红色，左孩子为红或者黑色</li>
</ol>
情况1修正后会变为情况2,3,4中一种，但是变为情况2的话，由于x此时的父亲结点为红，情况2中的循环下次就会结束；情况2中x结点会上移到其父亲，如果其父亲为黑色，那么可以变为1,2,3,4中任意一种情况；情况3一定变为情况4，情况4就会结束循环。情况2是while循环可以重复执行的唯一情况，指针x沿树上升至多O(lgn)次。

RB-DELETE-FIXUP操作花费O(lgn)次，做至多3次旋转。

&nbsp;

&nbsp;

&nbsp;